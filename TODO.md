### TODO

- [x] Abstract  
    - [x] Short description of the contents
- [x] Overview
    - [x] What this article is about
    - [x] Who is the article for
    - [x] Quick overview of what’s ahead
    - [x] Main idea: generating constraint rules from the source code
- [ ] Introduction
    - [x] Represent types as terms
    - [x] Use unification
        - [ ] Find the most general unifier
    - [x] Use constraint rules for type checking and type inference
    - [x] Generate constraint rules
    - [ ] Type checking and type inference as CLP
- [ ] Constraints rules
    - [x] Section intro, what’s being discussed, why read it
    - [x] User-defined constraints, built-in constraints.
    - [x] Equality and unification predicates
    - [x] Logical variables
    - [x] Constraint rule structure
    - [x] Calling arbitrary code.
    - [x] Constraint lifecycle
    - [ ] Activating constraints from the user code.
    - [ ] Stack
- [ ] Lambda calculus
    - [x] Language definition, examples
    - [x] Language Structure
    - [x] Types
    - [ ] Type checking and type inference
        - [x] Type term definition
        - [x] Constraints
            - [x] newType, asType
        - [x] Typing rules
        - [ ] Type recovery
- [ ] Type checking aspect
    - [ ] Type terms as datatype
        - [ ] recover the SNode 
    - [ ] Type initialization
    - [ ] Typing rules, fragments
        - [ ] Stand-alone, for each
        - [ ] templates structure: head, guard, body, alternatives
    - [ ] Handlers, stages
    - [ ] Activation trace
    - [ ] Example of running type checking
- [ ] Conclusion
    - [x] What has been just presented
    - [x] What are practical applications
    - [ ] What has not been covered
    - [x] Beyond type checking
    - [ ] Future work
- [x] Acknowledgements
    - [x] CHR
    - [x] JCHR
    - [x] Unification algorithm and term algebra
    - [x] Simply typed lambda calculus
    - [x] Hindley-Milner type inference algorithm 
